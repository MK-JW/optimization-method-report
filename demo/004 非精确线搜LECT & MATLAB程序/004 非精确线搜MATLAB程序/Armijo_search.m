function [alpha_acceptable,x_next,f_next,k]=Armijo_search(f_test,g_test,x_current,d_current,rho)
%==========================================================================
%函数调用格式：
%[alpha_acceptable,x_next,f_next,k]=Armijo_search(@f_test,@g_test,x_current,d_current,rho)
%--------------------------------------------------------------------------
%输入参数说明
%--------------------------------------------------------------------------
%f_test：目标函数
%g_test：目标函数对变量x的导数
%x_current：x在向量空间中的当前点（已确定）
%d_current：f_test在x_current的下降搜索方向（已确定）
%rho：可接受系数，0<rho<1
%--------------------------------------------------------------------------
%输出参数
%--------------------------------------------------------------------------
%alpha_acceptable：由Armijo搜索获得的可接受步长
%x_next：x_next=x_current+alpha_acceptable*d_current
%f_next：对应于x_next的函数值
%k：完成Armijo搜索所需的迭代次数
%==========================================================================
%==========================================================================
%主程序及说明
%--------------------------------------------------------------------------
%在调用本程序的上级程序中定义f_test和g_test的表达式
%alpha_k:经过k次Armijo搜索后，获得的步长值
%alpha_k_temp:临时存储alpha_k，旧的alpha_k在程序中还要保留用于赋值
%alpha_lower_k：经过k次Armijo搜索后，alpha_k的下限
%alpha_upper_k：经过k次Armijo搜索后，alpha_k的上限
%alpha_lower_k的初值设为0
%alpha_upper_k的初值为alpha_initial
%alpha_lower_k：在Armijo搜索中永远不变
%alpha_upper_k：使用两点内插公式更新，在[alpha_lower_k,alpha_k]
%f_current：f_test在x_current处的函数值
%g_current：g_test在x_current处的函数值
%在Armijo搜索中x_lower_k总是等于x_current
%f_alpha_lower_k：f_test在x_lower_k处的函数值，在Armijo搜索中总是等于f_current
%g_alpha_lower_k：g_test在x_lower_k处的函数值，在Armijo搜索中总是等于g_current
%df_alpha_lower_k：f_test对alpha的导数在x_lower_k处的函数值，在Armijo搜索中总是等于(d_current)'*g_current
%x_alpha_k=x_current+alpha_k*d_current
%f_alpha_k：f_test在x_alpha_k处的函数值
%g_alpha_k：g_test在x_alpha_k处的函数值
%df_alpha_k：f_test对alpha的导数在x_alpha_k处的函数值
%k_max：最大迭代次数，防止程序陷入循环而设置，在这里设为1000
%--------------------------------------------------------------------------
k_max=1000;
k=0;
f_current=f_test(x_current);
g_current=g_test(x_current);
f_alpha_lower_k=f_current;
%alpha_lower_k初值为0，此时f_alpha_lower_k等于f_current
g_alpha_lower_k=g_current;
df_alpha_lower_k=(d_current')*g_current;
f_alpha_lower_0=f_alpha_lower_k;
df_alpha_lower_0=df_alpha_lower_k;
%--------------------------------------------------------------------------
%估计alpha_initial的值，并防止alpha_initial过大或过小
%--------------------------------------------------------------------------
alpha_lower_k=0;
alpha_upper_k=1e8;
alpha_k=alpha_upper_k;
%--------------------------------------------------------------------------
%开始Armijo非精确插值搜索
%--------------------------------------------------------------------------
for k=1:k_max
    x_alpha_k=x_current+alpha_k*d_current;
    f_alpha_k=f_test(x_alpha_k);
    Armijo_condition=f_alpha_k-f_alpha_lower_0-rho*alpha_k*df_alpha_lower_0;
    if(Armijo_condition<=0)
        alpha_acceptable=alpha_k;
        x_next=x_alpha_k;
        f_next=f_alpha_k;
        break;
    else
        if(alpha_k<alpha_upper_k)
            alpha_upper_k=alpha_k;
        end
        alpha_k=alpha_lower_k+(1/2)*((alpha_k^2)*df_alpha_lower_k)/(f_alpha_lower_k-f_alpha_k+alpha_k*df_alpha_lower_k);
    end
end
if(k==k_max)
    disp('Armijo inexact line search algorithm failed');
    %经过k_max次搜索后未找到可接受的步长
    alpha_acceptable=NaN;
    x_next=NaN;
    f_next=NaN;
end
end
%==========================================================================

